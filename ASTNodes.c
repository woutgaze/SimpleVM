// Generated by SimpleVM.GenerateASTNodes

#include <stdlib.h>
#include <stdio.h>
#include "ASTNodes.h"


Node *newArgument(const char * name) {
    ArgumentNode *node = (ArgumentNode *) malloc(sizeof(ArgumentNode));
    node->super.type = ARGUMENT_NODE;
    node->name = name;
    return (Node *) node;
}

Node *newArrayConstruction(Node ** elements, uint32_t elements_size) {
    ArrayConstructionNode *node = (ArrayConstructionNode *) malloc(sizeof(ArrayConstructionNode));
    node->super.type = ARRAY_CONSTRUCTION_NODE;
    node->elements.elements = elements;
    node->elements.size = elements_size;
    return (Node *) node;
}

Node *newConditional(Node * condition, Node * trueBranch, Node * falseBranch) {
    ConditionalNode *node = (ConditionalNode *) malloc(sizeof(ConditionalNode));
    node->super.type = CONDITIONAL_NODE;
    node->condition = condition;
    node->trueBranch = trueBranch;
    node->falseBranch = falseBranch;
    return (Node *) node;
}

Node *newFalse() {
    FalseNode *node = (FalseNode *) malloc(sizeof(FalseNode));
    node->super.type = FALSE_NODE;
    return (Node *) node;
}

Node *newInt(int value) {
    IntNode *node = (IntNode *) malloc(sizeof(IntNode));
    node->super.type = INT_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newNaryMessage(Node * receiver, const char * selector, Node ** arguments, uint32_t arguments_size) {
    NaryMessageNode *node = (NaryMessageNode *) malloc(sizeof(NaryMessageNode));
    node->super.type = NARY_MESSAGE_NODE;
    node->receiver = receiver;
    node->selector = selector;
    node->arguments.elements = arguments;
    node->arguments.size = arguments_size;
    return (Node *) node;
}

Node *newNil() {
    NilNode *node = (NilNode *) malloc(sizeof(NilNode));
    node->super.type = NIL_NODE;
    return (Node *) node;
}

Node *newPrimArrayAt(Node * value, uint32_t index) {
    PrimArrayAtNode *node = (PrimArrayAtNode *) malloc(sizeof(PrimArrayAtNode));
    node->super.type = PRIM_ARRAY_AT_NODE;
    node->value = value;
    node->index = index;
    return (Node *) node;
}

Node *newPrimEquals(Node * left, Node * right) {
    PrimEqualsNode *node = (PrimEqualsNode *) malloc(sizeof(PrimEqualsNode));
    node->super.type = PRIM_EQUALS_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimGetArraySize(Node * value) {
    PrimGetArraySizeNode *node = (PrimGetArraySizeNode *) malloc(sizeof(PrimGetArraySizeNode));
    node->super.type = PRIM_GET_ARRAY_SIZE_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newPrimIntAdd(Node * left, Node * right) {
    PrimIntAddNode *node = (PrimIntAddNode *) malloc(sizeof(PrimIntAddNode));
    node->super.type = PRIM_INT_ADD_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntDiv(Node * left, Node * right) {
    PrimIntDivNode *node = (PrimIntDivNode *) malloc(sizeof(PrimIntDivNode));
    node->super.type = PRIM_INT_DIV_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntMul(Node * left, Node * right) {
    PrimIntMulNode *node = (PrimIntMulNode *) malloc(sizeof(PrimIntMulNode));
    node->super.type = PRIM_INT_MUL_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntRem(Node * left, Node * right) {
    PrimIntRemNode *node = (PrimIntRemNode *) malloc(sizeof(PrimIntRemNode));
    node->super.type = PRIM_INT_REM_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntSub(Node * left, Node * right) {
    PrimIntSubNode *node = (PrimIntSubNode *) malloc(sizeof(PrimIntSubNode));
    node->super.type = PRIM_INT_SUB_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimNot(Node * value) {
    PrimNotNode *node = (PrimNotNode *) malloc(sizeof(PrimNotNode));
    node->super.type = PRIM_NOT_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newPrimSmallerThan(Node * left, Node * right) {
    PrimSmallerThanNode *node = (PrimSmallerThanNode *) malloc(sizeof(PrimSmallerThanNode));
    node->super.type = PRIM_SMALLER_THAN_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimStringConcat(Node * left, Node * right) {
    PrimStringConcatNode *node = (PrimStringConcatNode *) malloc(sizeof(PrimStringConcatNode));
    node->super.type = PRIM_STRING_CONCAT_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimStringIntern(Node * value) {
    PrimStringInternNode *node = (PrimStringInternNode *) malloc(sizeof(PrimStringInternNode));
    node->super.type = PRIM_STRING_INTERN_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newReadArg(uint32_t index) {
    ReadArgNode *node = (ReadArgNode *) malloc(sizeof(ReadArgNode));
    node->super.type = READ_ARG_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReadIndexed(uint32_t index) {
    ReadIndexedNode *node = (ReadIndexedNode *) malloc(sizeof(ReadIndexedNode));
    node->super.type = READ_INDEXED_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReadInstVar(uint32_t index) {
    ReadInstVarNode *node = (ReadInstVarNode *) malloc(sizeof(ReadInstVarNode));
    node->super.type = READ_INST_VAR_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReadTemp(uint32_t index) {
    ReadTempNode *node = (ReadTempNode *) malloc(sizeof(ReadTempNode));
    node->super.type = READ_TEMP_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReturn(Node * value) {
    ReturnNode *node = (ReturnNode *) malloc(sizeof(ReturnNode));
    node->super.type = RETURN_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newSelf() {
    SelfNode *node = (SelfNode *) malloc(sizeof(SelfNode));
    node->super.type = SELF_NODE;
    return (Node *) node;
}

Node *newSequence(Node ** statements, uint32_t statements_size) {
    SequenceNode *node = (SequenceNode *) malloc(sizeof(SequenceNode));
    node->super.type = SEQUENCE_NODE;
    node->statements.elements = statements;
    node->statements.size = statements_size;
    return (Node *) node;
}

Node *newString(const char * value) {
    StringNode *node = (StringNode *) malloc(sizeof(StringNode));
    node->super.type = STRING_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newTrue() {
    TrueNode *node = (TrueNode *) malloc(sizeof(TrueNode));
    node->super.type = TRUE_NODE;
    return (Node *) node;
}

Node *newUnaryMessage(Node * receiver, const char * selector) {
    UnaryMessageNode *node = (UnaryMessageNode *) malloc(sizeof(UnaryMessageNode));
    node->super.type = UNARY_MESSAGE_NODE;
    node->receiver = receiver;
    node->selector = selector;
    return (Node *) node;
}

Node *newWhileTrue(Node * condition, Node * body) {
    WhileTrueNode *node = (WhileTrueNode *) malloc(sizeof(WhileTrueNode));
    node->super.type = WHILE_TRUE_NODE;
    node->condition = condition;
    node->body = body;
    return (Node *) node;
}

Node *newWriteIndexed(uint32_t index, Node * value) {
    WriteIndexedNode *node = (WriteIndexedNode *) malloc(sizeof(WriteIndexedNode));
    node->super.type = WRITE_INDEXED_NODE;
    node->index = index;
    node->value = value;
    return (Node *) node;
}

Node *newWriteInstVar(uint32_t index, Node * value) {
    WriteInstVarNode *node = (WriteInstVarNode *) malloc(sizeof(WriteInstVarNode));
    node->super.type = WRITE_INST_VAR_NODE;
    node->index = index;
    node->value = value;
    return (Node *) node;
}

Node *newWriteTemp(uint32_t index, Node * value) {
    WriteTempNode *node = (WriteTempNode *) malloc(sizeof(WriteTempNode));
    node->super.type = WRITE_TEMP_NODE;
    node->index = index;
    node->value = value;
    return (Node *) node;
}

Node *newBlock(ArgumentNode ** arguments, uint32_t arguments_size, ArgumentNode ** temporaries, uint32_t temporaries_size, Node * body) {
    BlockNode *node = (BlockNode *) malloc(sizeof(BlockNode));
    node->super.type = BLOCK_NODE;
    node->arguments.elements = arguments;
    node->arguments.size = arguments_size;
    node->temporaries.elements = temporaries;
    node->temporaries.size = temporaries_size;
    node->body = body;
    return (Node *) node;
}

Node *newMethod(const char * selector, BlockNode * block) {
    MethodNode *node = (MethodNode *) malloc(sizeof(MethodNode));
    node->super.type = METHOD_NODE;
    node->selector = selector;
    node->block = block;
    return (Node *) node;
}

Node *newClassSide(ArgumentNode ** instVars, uint32_t instVars_size, MethodNode ** methods, uint32_t methods_size) {
    ClassSideNode *node = (ClassSideNode *) malloc(sizeof(ClassSideNode));
    node->super.type = CLASS_SIDE_NODE;
    node->instVars.elements = instVars;
    node->instVars.size = instVars_size;
    node->methods.elements = methods;
    node->methods.size = methods_size;
    return (Node *) node;
}

Node *newClass(const char * name, const char * superName, uint32_t indexedType, ClassSideNode * instSide, ClassSideNode * classSide) {
    ClassNode *node = (ClassNode *) malloc(sizeof(ClassNode));
    node->super.type = CLASS_NODE;
    node->name = name;
    node->superName = superName;
    node->indexedType = indexedType;
    node->instSide = instSide;
    node->classSide = classSide;
    return (Node *) node;
}

