// Generated by SimpleVM.GenerateASTNodes

#include <stdlib.h>
#include <stdio.h>
#include "ASTNodes.h"


Node *newArgument(SizedString name) {
    ArgumentNode *node = (ArgumentNode *) malloc(sizeof(ArgumentNode));
    node->super.type = ARGUMENT_NODE;
    node->name = name;
    return (Node *) node;
}

Node *newArithmeticLoop(uint32_t varIndex, uint32_t stopIndex, Node * start, Node * stop, Node * sequence) {
    ArithmeticLoopNode *node = (ArithmeticLoopNode *) malloc(sizeof(ArithmeticLoopNode));
    node->super.type = ARITHMETIC_LOOP_NODE;
    node->varIndex = varIndex;
    node->stopIndex = stopIndex;
    node->start = start;
    node->stop = stop;
    node->sequence = sequence;
    return (Node *) node;
}

Node *newArrayConstruction(Node ** elements, uint32_t elements_size) {
    ArrayConstructionNode *node = (ArrayConstructionNode *) malloc(sizeof(ArrayConstructionNode));
    node->super.type = ARRAY_CONSTRUCTION_NODE;
    node->elements.elements = elements;
    node->elements.size = elements_size;
    return (Node *) node;
}

Node *newBinaryMessage(SizedString selector, Node * receiver, Node * arg1) {
    BinaryMessageNode *node = (BinaryMessageNode *) malloc(sizeof(BinaryMessageNode));
    node->super.type = BINARY_MESSAGE_NODE;
    node->selector = selector;
    node->receiver = receiver;
    node->arg1 = arg1;
    return (Node *) node;
}

Node *newCompiledCode(uint32_t argumentsSize, uint32_t temporariesSize, uint32_t maxStackDepth, uint32_t instructionsSize, char* bytecode, uint32_t bytecode_size) {
    CompiledCodeNode *node = (CompiledCodeNode *) malloc(sizeof(CompiledCodeNode));
    node->super.type = COMPILED_CODE_NODE;
    node->argumentsSize = argumentsSize;
    node->temporariesSize = temporariesSize;
    node->maxStackDepth = maxStackDepth;
    node->instructionsSize = instructionsSize;
    node->bytecode.elements = bytecode;
    node->bytecode.size = bytecode_size;
    return (Node *) node;
}

Node *newConditional(Node * condition, Node * trueBranch, Node * falseBranch) {
    ConditionalNode *node = (ConditionalNode *) malloc(sizeof(ConditionalNode));
    node->super.type = CONDITIONAL_NODE;
    node->condition = condition;
    node->trueBranch = trueBranch;
    node->falseBranch = falseBranch;
    return (Node *) node;
}

Node *newFalse() {
    FalseNode *node = (FalseNode *) malloc(sizeof(FalseNode));
    node->super.type = FALSE_NODE;
    return (Node *) node;
}

Node *newGlobalRead(SizedString name) {
    GlobalReadNode *node = (GlobalReadNode *) malloc(sizeof(GlobalReadNode));
    node->super.type = GLOBAL_READ_NODE;
    node->name = name;
    return (Node *) node;
}

Node *newInt(int value) {
    IntNode *node = (IntNode *) malloc(sizeof(IntNode));
    node->super.type = INT_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newJumpFalse(uint32_t offset, Node * value) {
    JumpFalseNode *node = (JumpFalseNode *) malloc(sizeof(JumpFalseNode));
    node->super.type = JUMP_FALSE_NODE;
    node->offset = offset;
    node->value = value;
    return (Node *) node;
}

Node *newJump(int offset) {
    JumpNode *node = (JumpNode *) malloc(sizeof(JumpNode));
    node->super.type = JUMP_NODE;
    node->offset = offset;
    return (Node *) node;
}

Node *newNaryMessage(SizedString selector, Node * receiver, Node ** arguments, uint32_t arguments_size) {
    NaryMessageNode *node = (NaryMessageNode *) malloc(sizeof(NaryMessageNode));
    node->super.type = NARY_MESSAGE_NODE;
    node->selector = selector;
    node->receiver = receiver;
    node->arguments.elements = arguments;
    node->arguments.size = arguments_size;
    return (Node *) node;
}

Node *newNil() {
    NilNode *node = (NilNode *) malloc(sizeof(NilNode));
    node->super.type = NIL_NODE;
    return (Node *) node;
}

Node *newPop(Node * value) {
    PopNode *node = (PopNode *) malloc(sizeof(PopNode));
    node->super.type = POP_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newPrimArrayAt(uint32_t index, Node * value) {
    PrimArrayAtNode *node = (PrimArrayAtNode *) malloc(sizeof(PrimArrayAtNode));
    node->super.type = PRIM_ARRAY_AT_NODE;
    node->index = index;
    node->value = value;
    return (Node *) node;
}

Node *newPrimEquals(Node * left, Node * right) {
    PrimEqualsNode *node = (PrimEqualsNode *) malloc(sizeof(PrimEqualsNode));
    node->super.type = PRIM_EQUALS_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimGetArraySize(Node * value) {
    PrimGetArraySizeNode *node = (PrimGetArraySizeNode *) malloc(sizeof(PrimGetArraySizeNode));
    node->super.type = PRIM_GET_ARRAY_SIZE_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newPrimIntAdd(Node * left, Node * right) {
    PrimIntAddNode *node = (PrimIntAddNode *) malloc(sizeof(PrimIntAddNode));
    node->super.type = PRIM_INT_ADD_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntDiv(Node * left, Node * right) {
    PrimIntDivNode *node = (PrimIntDivNode *) malloc(sizeof(PrimIntDivNode));
    node->super.type = PRIM_INT_DIV_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntMul(Node * left, Node * right) {
    PrimIntMulNode *node = (PrimIntMulNode *) malloc(sizeof(PrimIntMulNode));
    node->super.type = PRIM_INT_MUL_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntRem(Node * left, Node * right) {
    PrimIntRemNode *node = (PrimIntRemNode *) malloc(sizeof(PrimIntRemNode));
    node->super.type = PRIM_INT_REM_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntSmallerOrEqual(Node * left, Node * right) {
    PrimIntSmallerOrEqualNode *node = (PrimIntSmallerOrEqualNode *) malloc(sizeof(PrimIntSmallerOrEqualNode));
    node->super.type = PRIM_INT_SMALLER_OR_EQUAL_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntSmallerThan(Node * left, Node * right) {
    PrimIntSmallerThanNode *node = (PrimIntSmallerThanNode *) malloc(sizeof(PrimIntSmallerThanNode));
    node->super.type = PRIM_INT_SMALLER_THAN_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimIntSub(Node * left, Node * right) {
    PrimIntSubNode *node = (PrimIntSubNode *) malloc(sizeof(PrimIntSubNode));
    node->super.type = PRIM_INT_SUB_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimNot(Node * value) {
    PrimNotNode *node = (PrimNotNode *) malloc(sizeof(PrimNotNode));
    node->super.type = PRIM_NOT_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newPrimStringConcat(Node * left, Node * right) {
    PrimStringConcatNode *node = (PrimStringConcatNode *) malloc(sizeof(PrimStringConcatNode));
    node->super.type = PRIM_STRING_CONCAT_NODE;
    node->left = left;
    node->right = right;
    return (Node *) node;
}

Node *newPrimStringIntern(Node * value) {
    PrimStringInternNode *node = (PrimStringInternNode *) malloc(sizeof(PrimStringInternNode));
    node->super.type = PRIM_STRING_INTERN_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newPushBlock(Node * block) {
    PushBlockNode *node = (PushBlockNode *) malloc(sizeof(PushBlockNode));
    node->super.type = PUSH_BLOCK_NODE;
    node->block = block;
    return (Node *) node;
}

Node *newReadArg(uint32_t index) {
    ReadArgNode *node = (ReadArgNode *) malloc(sizeof(ReadArgNode));
    node->super.type = READ_ARG_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReadIndexed(uint32_t index) {
    ReadIndexedNode *node = (ReadIndexedNode *) malloc(sizeof(ReadIndexedNode));
    node->super.type = READ_INDEXED_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReadInstVar(uint32_t index) {
    ReadInstVarNode *node = (ReadInstVarNode *) malloc(sizeof(ReadInstVarNode));
    node->super.type = READ_INST_VAR_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReadOuterArg(uint32_t index, uint32_t outer) {
    ReadOuterArgNode *node = (ReadOuterArgNode *) malloc(sizeof(ReadOuterArgNode));
    node->super.type = READ_OUTER_ARG_NODE;
    node->index = index;
    node->outer = outer;
    return (Node *) node;
}

Node *newReadOuterTemp(uint32_t index, uint32_t outer) {
    ReadOuterTempNode *node = (ReadOuterTempNode *) malloc(sizeof(ReadOuterTempNode));
    node->super.type = READ_OUTER_TEMP_NODE;
    node->index = index;
    node->outer = outer;
    return (Node *) node;
}

Node *newReadTemp(uint32_t index) {
    ReadTempNode *node = (ReadTempNode *) malloc(sizeof(ReadTempNode));
    node->super.type = READ_TEMP_NODE;
    node->index = index;
    return (Node *) node;
}

Node *newReturn(Node * value) {
    ReturnNode *node = (ReturnNode *) malloc(sizeof(ReturnNode));
    node->super.type = RETURN_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newSelf() {
    SelfNode *node = (SelfNode *) malloc(sizeof(SelfNode));
    node->super.type = SELF_NODE;
    return (Node *) node;
}

Node *newString(SizedString value) {
    StringNode *node = (StringNode *) malloc(sizeof(StringNode));
    node->super.type = STRING_NODE;
    node->value = value;
    return (Node *) node;
}

Node *newTernaryMessage(SizedString selector, Node * receiver, Node * arg1, Node * arg2) {
    TernaryMessageNode *node = (TernaryMessageNode *) malloc(sizeof(TernaryMessageNode));
    node->super.type = TERNARY_MESSAGE_NODE;
    node->selector = selector;
    node->receiver = receiver;
    node->arg1 = arg1;
    node->arg2 = arg2;
    return (Node *) node;
}

Node *newTrue() {
    TrueNode *node = (TrueNode *) malloc(sizeof(TrueNode));
    node->super.type = TRUE_NODE;
    return (Node *) node;
}

Node *newUnaryMessage(SizedString selector, Node * receiver) {
    UnaryMessageNode *node = (UnaryMessageNode *) malloc(sizeof(UnaryMessageNode));
    node->super.type = UNARY_MESSAGE_NODE;
    node->selector = selector;
    node->receiver = receiver;
    return (Node *) node;
}

Node *newWhileTrue(Node * condition, Node * body) {
    WhileTrueNode *node = (WhileTrueNode *) malloc(sizeof(WhileTrueNode));
    node->super.type = WHILE_TRUE_NODE;
    node->condition = condition;
    node->body = body;
    return (Node *) node;
}

Node *newWriteIndexed(uint32_t index, Node * value) {
    WriteIndexedNode *node = (WriteIndexedNode *) malloc(sizeof(WriteIndexedNode));
    node->super.type = WRITE_INDEXED_NODE;
    node->index = index;
    node->value = value;
    return (Node *) node;
}

Node *newWriteInstVar(uint32_t index, Node * value) {
    WriteInstVarNode *node = (WriteInstVarNode *) malloc(sizeof(WriteInstVarNode));
    node->super.type = WRITE_INST_VAR_NODE;
    node->index = index;
    node->value = value;
    return (Node *) node;
}

Node *newWriteOuterTemp(uint32_t index, uint32_t outer, Node * value) {
    WriteOuterTempNode *node = (WriteOuterTempNode *) malloc(sizeof(WriteOuterTempNode));
    node->super.type = WRITE_OUTER_TEMP_NODE;
    node->index = index;
    node->outer = outer;
    node->value = value;
    return (Node *) node;
}

Node *newWriteTemp(uint32_t index, Node * value) {
    WriteTempNode *node = (WriteTempNode *) malloc(sizeof(WriteTempNode));
    node->super.type = WRITE_TEMP_NODE;
    node->index = index;
    node->value = value;
    return (Node *) node;
}

Node *newCompiledMethod(SizedString selector, CompiledCodeNode * code) {
    CompiledMethodNode *node = (CompiledMethodNode *) malloc(sizeof(CompiledMethodNode));
    node->super.type = COMPILED_METHOD_NODE;
    node->selector = selector;
    node->code = code;
    return (Node *) node;
}

Node *newSequence(ArgumentNode ** temporaries, uint32_t temporaries_size, Node ** statements, uint32_t statements_size) {
    SequenceNode *node = (SequenceNode *) malloc(sizeof(SequenceNode));
    node->super.type = SEQUENCE_NODE;
    node->temporaries.elements = temporaries;
    node->temporaries.size = temporaries_size;
    node->statements.elements = statements;
    node->statements.size = statements_size;
    return (Node *) node;
}

Node *newBlock(ArgumentNode ** arguments, uint32_t arguments_size, SequenceNode * body) {
    BlockNode *node = (BlockNode *) malloc(sizeof(BlockNode));
    node->super.type = BLOCK_NODE;
    node->arguments.elements = arguments;
    node->arguments.size = arguments_size;
    node->body = body;
    return (Node *) node;
}

Node *newCompiledClassSide(ArgumentNode ** instVars, uint32_t instVars_size, CompiledMethodNode ** methods, uint32_t methods_size) {
    CompiledClassSideNode *node = (CompiledClassSideNode *) malloc(sizeof(CompiledClassSideNode));
    node->super.type = COMPILED_CLASS_SIDE_NODE;
    node->instVars.elements = instVars;
    node->instVars.size = instVars_size;
    node->methods.elements = methods;
    node->methods.size = methods_size;
    return (Node *) node;
}

Node *newCompiledClass(SizedString name, SizedString superName, uint32_t indexedType, CompiledClassSideNode * instSide, CompiledClassSideNode * classSide) {
    CompiledClassNode *node = (CompiledClassNode *) malloc(sizeof(CompiledClassNode));
    node->super.type = COMPILED_CLASS_NODE;
    node->name = name;
    node->superName = superName;
    node->indexedType = indexedType;
    node->instSide = instSide;
    node->classSide = classSide;
    return (Node *) node;
}

Node *newMethod(SizedString selector, BlockNode * block) {
    MethodNode *node = (MethodNode *) malloc(sizeof(MethodNode));
    node->super.type = METHOD_NODE;
    node->selector = selector;
    node->block = block;
    return (Node *) node;
}

Node *newClassSide(ArgumentNode ** instVars, uint32_t instVars_size, MethodNode ** methods, uint32_t methods_size) {
    ClassSideNode *node = (ClassSideNode *) malloc(sizeof(ClassSideNode));
    node->super.type = CLASS_SIDE_NODE;
    node->instVars.elements = instVars;
    node->instVars.size = instVars_size;
    node->methods.elements = methods;
    node->methods.size = methods_size;
    return (Node *) node;
}

Node *newClass(SizedString name, SizedString superName, uint32_t indexedType, ClassSideNode * instSide, ClassSideNode * classSide) {
    ClassNode *node = (ClassNode *) malloc(sizeof(ClassNode));
    node->super.type = CLASS_NODE;
    node->name = name;
    node->superName = superName;
    node->indexedType = indexedType;
    node->instSide = instSide;
    node->classSide = classSide;
    return (Node *) node;
}

